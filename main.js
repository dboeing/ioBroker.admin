/**
 *      Admin backend
 *
 *      Controls Adapter-Processes
 *
 *      Copyright 2014-2023 bluefox <dogafox@gmail.com>,
 *      MIT License
 *
 */

/* jshint -W097 */
/* jshint strict: false */
/* jslint node: true */
'use strict';

const semver = require('semver');
const axios = require('axios').default;
const fs = require('fs');

const utils = require('@iobroker/adapter-core'); // Get common adapter utils
const getInstalledInfo = utils.commonTools.getInstalledInfo;
const SocketAdmin = require('@iobroker/socket-classes').SocketAdmin;
const ws = require('@iobroker/ws-server');

const adapterName = require('./package.json').name.split('.').pop();
const Web = require('./lib/web');

const ONE_HOUR_MS = 3_600_000;
const ERROR_PERMISSION = 'permissionError';

const CURRENT_MAX_MAJOR_NODEJS = 18;
const CURRENT_MAX_MAJOR_NPM = 8;

let socket = null;
let webServer = null;
let lastRepoUpdate = null;

let objects = {};
const secret = 'Zgfr56gFe87jJOM'; // Will be generated by first start
let systemLanguage = 'en';

class Admin extends utils.Adapter {
    /** secret used for the socket connection */
    secret;

    /**
     * @param {Partial<utils.AdapterOptions>} [options={}]
     */
    constructor(options = {}) {
        options = {
            ...options,
            name: adapterName, // adapter name
            dirname: __dirname, // say own position
            logTransporter: true, // receive the logs
            systemConfig: true,
            install: callback => typeof callback === 'function' && callback(),
        };

        /** @ts-expect-error */
        super(options);

        this.on('objectChange', this.onObjectChange.bind(this));
        this.on('stateChange', this.onStateChange.bind(this));
        this.on('ready', this.onReady.bind(this));
        this.on('message', this.onMessage.bind(this));
        this.on('unload', this.onUnload.bind(this));
        this.on('fileChange', this.onFileChange.bind(this));
        this.on('log', this.onLog.bind(this));
    }

    /**
     * Is called if a subscribed object changes
     * @param {string} id
     * @param {ioBroker.Object | null | undefined} obj
     */
    onObjectChange(id, obj) {
        if (obj) {
            // console.log('objectChange: ' + id);
            objects[id] = obj;

            if (id === 'system.config' && !this.config.language) {
                if (obj.common?.language) {
                    systemLanguage = obj.common.language;
                    webServer && webServer.setLanguage(systemLanguage);
                }
            }

            if (id === 'system.repositories' || id.match(/^system\.adapter\.[^.]+$/)) {
                this.updaterTimeout && clearTimeout(this.updaterTimeout);
                this.updaterTimeout = setTimeout(() => {
                    this.updaterTimeout = null;
                    this.writeUpdateInfo();
                }, 5_000);
            }
        } else {
            // console.log('objectDeleted: ' + id);
            if (objects[id]) {
                delete objects[id];
            }
        }

        // TODO Build in some threshold of messages
        socket && socket.objectChange(id, obj);
    }

    /**
     * Is called if a subscribed state changes
     * @param {string} id
     * @param {ioBroker.State | null | undefined} state
     */
    onStateChange(id, state) {
        if (socket) {
            socket.stateChange(id, state);
        }
    }

    onFileChange(id, fileName, size) {
        if (socket) {
            socket.fileChange(id, fileName, size);
        }
    }

    /**
     * Is called when databases are connected and adapter received configuration.
     */
    onReady() {
        this.getForeignObject('system.config', (err, obj) => {
            if (!err && obj) {
                obj.native = obj.native || {};
                if (this.config.language) {
                    systemLanguage = this.config.language;
                } else if (obj.common?.language) {
                    systemLanguage = obj.common.language;
                }

                if (!obj.native.secret) {
                    require('crypto').randomBytes(24, (ex, buf) => {
                        this.secret = buf.toString('hex');
                        this.extendForeignObject('system.config', { native: { secret: this.secret } });
                        this.init();
                    });
                } else {
                    this.secret = obj.native.secret;
                    this.init();
                }
            } else {
                this.secret = secret;
                this.log.error('Cannot find object system.config');
            }
        });
    }

    /**
     * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...
     * Using this method requires "common.messagebox" property to be set to true in io-package.json
     * @param {ioBroker.Message} obj
     */
    onMessage(obj) {
        if (!obj) {
            return false;
        }
        if (obj.command === 'checkFiles') {
            if (typeof obj.message === 'string') {
                try {
                    return (
                        obj.callback &&
                        this.sendTo(obj.from, obj.command, { result: fs.existsSync(obj.message) }, obj.callback)
                    );
                } catch (e) {
                    return obj.callback && this.sendTo(obj.from, obj.command, { error: e.message }, obj.callback);
                }
            } else if (Array.isArray(obj.message)) {
                const result = {};
                for (let f = 0; f < obj.message.length; f++) {
                    try {
                        result[obj.message[f]] = fs.existsSync(obj.message[f]);
                    } catch (e) {
                        result[obj.message[f]] = e.message;
                    }
                }
                return obj.callback && this.sendTo(obj.from, obj.command, result, obj.callback);
            }
        } else if (obj.command === 'autocomplete') {
            // just for test
            return (
                obj.callback &&
                this.sendTo(
                    obj.from,
                    obj.command,
                    [
                        { value: 1, label: 'first' },
                        { value: 2, label: 'second' },
                    ],
                    obj.callback
                )
            );
        } else if (obj.command === 'selectSendTo') {
            this.log.info(`SelectSendTo: ${JSON.stringify(obj.message)}`);
            // just for test
            return (
                obj.callback &&
                this.sendTo(
                    obj.from,
                    obj.command,
                    [
                        { label: 'Afghanistan', value: 'AF' },
                        { label: 'Åland Islands', value: 'AX' },
                        { label: 'Albania', value: 'AL' },
                    ],
                    obj.callback
                )
            );
        } else if (obj.command === 'url') {
            this.log.info(`url: ${JSON.stringify(obj.message)}`);
            // just for test
            return (
                obj.callback &&
                this.sendTo(obj.from, obj.command, { openUrl: obj.message._origin, saveConfig: true }, obj.callback)
            );
        }

        socket && socket.sendCommand(obj);

        return true;
    }

    /**
     * Is called when adapter shuts down - callback has to be called under any circumstances!
     * @param {() => void} callback
     */
    onUnload(callback) {
        this.timerRepo && clearTimeout(this.timerRepo);
        this.timerRepo = null;

        this.timerNews && clearTimeout(this.timerNews);
        this.timerNews = null;

        this.ratingTimeout && clearTimeout(this.ratingTimeout);
        this.ratingTimeout = null;

        this.updaterTimeout && clearTimeout(this.updaterTimeout);
        this.updaterTimeout = null;

        try {
            this.log.info(`terminating http${this.config.secure ? 's' : ''} server on port ${this.config.port}`);
            socket && socket.close();
            webServer.close();
            callback();
        } catch (e) {
            callback();
        }
    }

    onLog(obj) {
        if (socket) {
            socket.sendLog(obj);
        }
    }

    createUpdateInfo() {
        const promises = [];
        // create connected object and state
        const updatesNumberObj = objects[`${this.namespace}.info.updatesNumber`];

        if (!updatesNumberObj || !updatesNumberObj.common || updatesNumberObj.common.type !== 'number') {
            const obj = {
                _id: 'info.updatesNumber',
                type: 'state',
                common: {
                    role: 'indicator.updates',
                    name: {
                        en: 'Number of adapters to update',
                        de: 'Anzahl der zu aktualisierenden Adapter',
                        ru: 'Количество адаптеров для обновления',
                        pt: 'Número de adaptadores para atualizar',
                        nl: 'Aantal adapters om te updaten',
                        fr: "Nombre d'adaptateurs à mettre à jour",
                        it: 'Numero di adattatori da aggiornare',
                        es: 'Número de adaptadores para actualizar',
                        pl: 'Liczba adapterów do aktualizacji',
                        'zh-cn': '要更新的适配器数量',
                    },
                    type: 'number',
                    read: true,
                    write: false,
                    def: 0,
                },
                native: {},
            };

            /** @ts-expect-error */
            this.setObject(obj._id, obj);
        }

        const updatesListObj = objects[`${this.namespace}.info.updatesList`];

        if (!updatesListObj || !updatesListObj.common || updatesListObj.common.type !== 'string') {
            const obj = {
                _id: 'info.updatesList',
                type: 'state',
                common: {
                    role: 'indicator.updates',
                    name: {
                        en: 'List of adapters to update',
                        de: 'Liste der zu aktualisierenden Adapter',
                        ru: 'Список адаптеров для обновления',
                        pt: 'Lista de adaptadores para atualizar',
                        nl: 'Lijst met adapters die moeten worden bijgewerkt',
                        fr: 'Liste des adaptateurs à mettre à jour',
                        it: 'Elenco degli adattatori da aggiornare',
                        es: 'Lista de adaptadores para actualizar',
                        pl: 'Lista adapterów do aktualizacji',
                        'zh-cn': '要更新的适配器列表',
                    },
                    type: 'string',
                    read: true,
                    write: false,
                    def: '',
                },
                native: {},
            };

            /** @ts-expect-error */
            this.setObject(obj._id, obj);
        }

        const newUpdatesObj = objects[`${this.namespace}.info.newUpdates`];

        if (!newUpdatesObj || !newUpdatesObj.common || newUpdatesObj.common.type !== 'boolean') {
            const obj = {
                _id: 'info.newUpdates',
                type: 'state',
                common: {
                    role: 'indicator.updates',
                    name: {
                        en: 'Indicator if new adapter updates are available',
                        de: 'Anzeige, ob neue Adapter-Updates verfügbar sind',
                        ru: 'Индикатор наличия новых обновлений адаптера',
                        pt: 'Indicador se novas atualizações do adaptador estão disponíveis',
                        nl: 'Indicator of er nieuwe adapter-updates beschikbaar zijn',
                        fr: "Indicateur si de nouvelles mises à jour de l'adaptateur sont disponibles",
                        it: "Indicatore se sono disponibili nuovi aggiornamenti dell'adattatore",
                        es: 'Indicador si hay nuevas actualizaciones de adaptadores disponibles',
                        pl: 'Wskaźnik, czy dostępne są nowe aktualizacje adaptera',
                        'zh-cn': '指示是否有新的适配器更新可用',
                    },
                    type: 'boolean',
                    read: true,
                    write: false,
                    def: false,
                },
                native: {},
            };

            /** @ts-expect-error */
            promises.push(this.setObjectAsync(obj._id, obj));
        }

        const updatesJsonObj = objects[`${this.namespace}.info.updatesJson`];

        if (!updatesJsonObj || !updatesJsonObj.common || updatesJsonObj.common.type !== 'string') {
            const obj = {
                _id: 'info.updatesJson',
                type: 'state',
                common: {
                    role: 'indicator.updates',
                    name: {
                        en: 'JSON string with adapter update information',
                        de: 'JSON-String mit Adapteraktualisierungsinformationen',
                        ru: 'Строка JSON с информацией об обновлении адаптера',
                        pt: 'String JSON com informações de atualização do adaptador',
                        nl: 'JSON-tekenreeks met adapter-update-informatie',
                        fr: "Chaîne JSON avec les informations de mise à jour de l'adaptateur",
                        it: "Stringa JSON con informazioni sull'aggiornamento dell'adattatore",
                        es: 'Cadena JSON con información de actualización del adaptador',
                        pl: 'Ciąg JSON z informacjami o aktualizacji adaptera',
                        'zh-cn': '带有适配器更新信息的 JSON 字符串',
                    },
                    type: 'string',
                    read: true,
                    write: false,
                    def: '{}',
                },
                native: {},
            };

            /** @ts-expect-error */
            promises.push(this.setObjectAsync(obj._id, obj));
        }

        const lastUpdateCheckObj = objects[`${this.namespace}.info.lastUpdateCheck`];

        if (!lastUpdateCheckObj || !lastUpdateCheckObj.common || lastUpdateCheckObj.common.type !== 'number') {
            const obj = {
                _id: 'info.lastUpdateCheck',
                type: 'state',
                common: {
                    role: 'value.time',
                    name: {
                        en: 'Timestamp of last update check',
                        de: 'Zeitstempel der letzten UpdatePrüfung',
                        ru: 'Отметка времени последней проверки обнвлений',
                        pt: 'Timestamp da última verificação de atualizaçã',
                        nl: 'Tijdstempel van laatste updatecontrole',
                        fr: 'Horodatage de la dernière vérificationde mise à jour',
                        it: "Timestamp dell'ultimo controllo di aggiornamento",
                        es: 'Marca de tiempo de la última verificación de actalización',
                        pl: 'Znacznik czasu ostatniego sprawdzenia aktualizacji',
                        'zh-cn': '上次更新检查的时间戳',
                    },
                    type: 'number',
                    read: true,
                    write: false,
                    def: 0,
                },
                native: {},
            };

            /** @ts-expect-error */
            promises.push(this.setObjectAsync(obj._id, obj));
        }

        return Promise.all(promises);
    }

    upToDate(v1, v2) {
        return semver.gt(v2, v1);
    }

    writeUpdateInfo(sources) {
        if (!objects['system.config'] || !objects['system.config'].common) {
            return this.log.warn('Repository cannot be read. Invalid "system.config" object.');
        }
        const activeRepo = objects['system.config'].common.activeRepo;
        const systemRepos = objects['system.repositories'];

        if (!sources) {
            sources = {};

            // If multi-repo case
            if (Array.isArray(activeRepo)) {
                if (systemRepos?.native?.repositories) {
                    activeRepo.forEach(repo => {
                        if (systemRepos.native.repositories[repo]?.json) {
                            Object.assign(sources, systemRepos.native.repositories[repo].json);
                        } else {
                            this.setState('info.updatesNumber', 0, true);
                            this.setState('info.updatesList', '', true);
                            this.setState('info.newUpdates', false, true);
                            this.setState('info.updatesJson', '{}', true);
                            this.setState('info.lastUpdateCheck', Date.now(), true);
                            if (systemRepos.native.repositories[repo]) {
                                this.log.warn(`Repository cannot be read: Active repo - ${repo}`);
                            } else {
                                this.log.warn('No repository source configured');
                            }
                        }
                    });
                }
            } else if (systemRepos?.native?.repositories?.[activeRepo]?.json) {
                sources = systemRepos.native.repositories[activeRepo].json;
            }
        }

        if (!Object.keys(sources).length) {
            this.setState('info.updatesNumber', 0, true);
            this.setState('info.updatesList', '', true);
            this.setState('info.newUpdates', false, true);
            this.setState('info.updatesJson', '{}', true);
            this.setState('info.lastUpdateCheck', Date.now(), true);
            if (Array.isArray(activeRepo)) {
                let found = false;
                if (systemRepos?.native?.repositories) {
                    activeRepo.forEach(repo => {
                        if (systemRepos.native.repositories[repo]) {
                            this.log.warn(`Active repository "${repo}" cannot be read`);
                            found = true;
                        }
                    });
                }
                !found &&
                    this.log.warn(
                        `No repository source configured. Possible values: ${
                            systemRepos?.native?.repositories
                                ? Object.keys(systemRepos.native.repositories).join(', ')
                                : 'none'
                        }. Active repo(s): "${activeRepo.join('", "')}"`
                    );
            } else {
                if (systemRepos?.native?.repositories?.[activeRepo]) {
                    this.log.warn(`Repository cannot be read. Active repo: ${activeRepo}`);
                } else {
                    this.log.warn(
                        `No repository source configured. Possible values: ${
                            systemRepos?.native?.repositories
                                ? Object.keys(systemRepos.native.repositories).join(', ')
                                : 'none'
                        }. Active repo: "${activeRepo}"`
                    );
                }
            }
            return;
        }

        const installed = getInstalledInfo();
        const list = [];
        const updatesJson = {};
        let newUpdateIndicator = false;

        this.getState('info.updatesJson', (err, state) => {
            let oldUpdates;
            if (typeof state?.val === 'string') {
                oldUpdates = JSON.parse(state.val) || {};
            } else {
                oldUpdates = {};
            }

            Object.keys(sources).forEach(name => {
                try {
                    if (installed[name]?.version && sources[name].version) {
                        if (
                            sources[name].version !== installed[name].version &&
                            !this.upToDate(sources[name].version, installed[name].version)
                        ) {
                            // Check if updates are new or already known to user
                            if (
                                !oldUpdates ||
                                !oldUpdates[name] ||
                                oldUpdates[name].availableVersion !== sources[name].version
                            ) {
                                newUpdateIndicator = true;
                            } // endIf
                            updatesJson[name] = {
                                availableVersion: sources[name].version,
                                installedVersion: installed[name].version,
                            };
                            // remove first part of the name
                            const n = name.indexOf('.');
                            list.push(n === -1 ? name : name.substring(n + 1));
                        }
                    }
                } catch (err) {
                    this.log.warn(`Error on version check for ${name}: ${err}`);
                }
            });

            this.setState('info.updatesNumber', list.length, true);
            this.setState('info.updatesList', list.join(', '), true);
            this.setState('info.newUpdates', newUpdateIndicator, true);
            this.setState('info.updatesJson', JSON.stringify(updatesJson), true);
            this.setState('info.lastUpdateCheck', Date.now(), true);
        });
    }

    initSocket(server, store) {
        socket = new SocketAdmin(this.config, this, objects);
        socket.start(server, ws, {
            userKey: 'connect.sid',
            store,
            secret: this.secret,
        });

        // subscribe on all object changes
        socket.subscribe('objectChange', '*');

        this.getForeignObjectAsync('system.meta.uuid')
            .then(async obj => {
                if (obj?.native) {
                    try {
                        await socket.updateRatings();
                    } catch (error) {
                        this.log.error(`Cannot fetch ratings: ${error}`);
                    }
                }
            })
            .catch(error => this.log.error(`Cannot read UUID: ${error}`));
    }

    processTasks() {
        if (!this._running && this._tasks.length) {
            this._running = true;

            const obj = this._tasks.shift();
            if (!obj.acl || obj.acl.owner !== this.config.defaultUser) {
                obj.acl.owner = this.config.defaultUser;
                this.setForeignObject(obj._id, obj, () =>
                    setImmediate(() => {
                        this._running = false;
                        this.processTasks();
                    })
                );
            } else {
                setImmediate(() => {
                    this._running = false;
                    this.processTasks();
                });
            }
        }
    }

    applyRightsToObjects(pattern, types, cb) {
        if (typeof types === 'object') {
            let count = types.length;
            types.forEach(type => this.applyRightsToObjects(pattern, type, () => !--count && cb && cb()));
        } else {
            this.getObjectView(
                'system',
                types,
                { startkey: `${pattern}.`, endkey: `${pattern}.\u9999` },
                (err, doc) => {
                    this._tasks = this._tasks || [];

                    if (!err && doc?.rows.length) {
                        for (let i = 0; i < doc.rows.length; i++) {
                            this._tasks.push(doc.rows[i].value);
                        }
                        this.processTasks();
                    }
                }
            );
        }
    }

    applyRights() {
        const promises = [];
        this.config.accessAllowedConfigs = this.config.accessAllowedConfigs || [];
        this.config.accessAllowedTabs = this.config.accessAllowedTabs || [];

        this.config.accessAllowedConfigs.forEach(id =>
            promises.push(
                new Promise(resolve =>
                    this.getForeignObject(`system.adapter.${id}`, (err, obj) => {
                        if (obj?.acl && obj.acl.owner !== this.config.defaultUser) {
                            obj.acl.owner = this.config.defaultUser;
                            this.setForeignObject(`system.adapter.${id}`, obj, err => resolve(!err));
                        } else {
                            resolve(false);
                        }
                    })
                )
            )
        );

        this.config.accessAllowedTabs.forEach(id => {
            if (id.startsWith('devices.')) {
                // change rights of all alias.*
                this.applyRightsToObjects('alias', ['state', 'channel']);
            } else if (id.startsWith('javascript.')) {
                // change rights of all script.js.*
                this.applyRightsToObjects('javascript', ['script', 'channel']);
            } else if (id.startsWith('fullcalendar.')) {
                // change rights of all fullcalendar.*
                this.applyRightsToObjects('fullcalendar', ['schedule']);
            } else if (id.startsWith('scenes.')) {
                // change rights of all scenes.*
                this.applyRightsToObjects('scenes', ['state', 'channel']);
            }
        });

        Promise.all(promises).then(results => {
            const len = results.filter(r => !!r).length;
            len && this.log.info(`Updated ${len} objects`);
        });
    }

    // read news from server
    updateNews() {
        this.timerNews && clearTimeout(this.timerNews);
        this.timerNews = null;

        this.checkNodeJsVersion().catch(e => this.log.warn(`Cannot check node.js versions: ${e}`));

        let oldEtag;
        let newNews;
        let oldNews;
        let originalOldNews;
        let newEtag;

        return (
            this.getStateAsync('info.newsETag')
                .then(state => {
                    oldEtag = state && state.val;
                    return axios
                        .get('https://iobroker.live/repo/news-hash.json', {
                            timeout: 13000,
                            validateStatus: status => status < 400,
                        })
                        .then(response => response.data)
                        .catch(error =>
                            this.log.warn(
                                `Cannot update news: ${
                                    error.response ? error.response.data : error.message || error.code
                                }`
                            )
                        );
                })
                .then(etag => {
                    if (etag && etag.hash !== oldEtag) {
                        newEtag = etag.hash;
                        return axios
                            .get('https://iobroker.live/repo/news.json', {
                                timeout: 14000,
                                validateStatus: status => status < 400,
                            })
                            .then(response => response.data)
                            .catch(error =>
                                this.log.warn(
                                    `Cannot update news_: ${
                                        error.response ? error.response.data : error.message || error.code
                                    }`
                                )
                            );
                    } else {
                        newEtag = oldEtag;
                        return Promise.resolve([]);
                    }
                })
                .then(_newNews => {
                    newNews = _newNews || [];
                    return this.getStateAsync('info.newsFeed');
                })
                .then(state => {
                    try {
                        /** @ts-expect-error */
                        oldNews = state && state.val ? JSON.parse(state.val) : [];
                    } catch (e) {
                        oldNews = [];
                    }
                    originalOldNews = JSON.stringify(oldNews);

                    return this.getStateAsync('info.newsLastId');
                })
                /** @ts-expect-error */
                .then(lastState => {
                    // find time of last ID
                    let time = '';
                    if (lastState && lastState.val) {
                        const item = oldNews.find(item => item.id === lastState.val);
                        if (item) {
                            time = item.created;
                        }
                    }

                    // add all IDs newer than last seen
                    newNews.forEach(item => {
                        if (!lastState || !time || item.created > time) {
                            if (!oldNews.find(it => it.created === item.created)) {
                                oldNews.push(item);
                            }
                        }
                    });

                    oldNews.sort((a, b) => (a.created > b.created ? -1 : a.created < b.created ? 1 : 0));

                    // delete news older than 3 months
                    let i;
                    for (i = oldNews.length - 1; i >= 0; i--) {
                        if (Date.now() - new Date(oldNews[i].created).getTime() > 180 * 24 * 3600000) {
                            oldNews.splice(i, 1);
                        }
                    }

                    if (originalOldNews !== JSON.stringify(oldNews)) {
                        return this.setStateAsync('info.newsFeed', JSON.stringify(oldNews), true);
                    } else {
                        return Promise.resolve();
                    }
                })
                /** @ts-expect-error */
                .then(() =>
                    newEtag !== oldEtag ? this.setStateAsync('info.newsETag', newEtag, true) : Promise.resolve()
                )
                .catch(e => this.log.error(`Cannot update news: ${e}`))
                .then(() => (this.timerNews = setTimeout(() => this.updateNews(), 24 * ONE_HOUR_MS + 1)))
        );
    }

    /**
     * Get current npm version from controller
     * @returns {Promise<string>}
     */
    async getNpmVersion() {
        /** @ts-expect-error */
        const hostInfo = await this.sendToHostAsync(this.host, 'getHostInfo', {});
        /** @ts-expect-error */
        return hostInfo.NPM;
    }

    async checkNodeJsVersion() {
        // allow only one admin instance to check the versions for every host
        if (this.instance !== 0) {
            const objs = await this.getObjectViewAsync('system', 'instance', {
                startkey: 'system.adapter.admin.',
                endkey: 'system.adapter.admin.\u9999',
            });
            let min = null;
            // find the lowest active instance on the same host
            for (const row of objs.rows) {
                const obj = row.value;
                if (obj?.common.enabled && obj.common.host === this.host) {
                    /** @ts-expect-error */
                    const instance = parseInt(row.id.split('.').pop());
                    if (min === null || min < instance) {
                        min = instance;
                    }
                }
            }
            if (this.instance !== min) {
                return;
            }
        }

        const response = await axios('https://nodejs.org/download/release/index.json');
        const result = {
            nodeNewest: '',
            nodeNewestNext: '',
            npmNewest: '',
            npmNewestNext: '',
            npmCurrent: '',
            nodeCurrent: process.version,
        };

        try {
            result.npmCurrent = await this.getNpmVersion();
        } catch (error) {
            this.log.warn(`Cannot get current npm version: ${error}`);
        }

        // https://nodejs.org/download/release/index.json
        // detect new version of the same major version and new major version (that is allowed by ioBroker)
        try {
            // find newest suggested version
            const nodeNewestNext = response.data.find(item => item.version.startsWith(`v${CURRENT_MAX_MAJOR_NODEJS}.`));
            const nodeCurrentMajor = process.version.split('.')[0];
            const nodeNewest = response.data.find(item => item.version.startsWith(`${nodeCurrentMajor}.`));
            if (nodeNewestNext) {
                result.nodeNewestNext = nodeNewestNext.version;
            }
            if (nodeNewest) {
                result.nodeNewest = nodeNewest.version;
            }

            // find newest suggested version
            const npmNewestNext =
                nodeNewestNext || response.data.find(item => item.npm.startsWith(`${CURRENT_MAX_MAJOR_NPM}.`));
            const npmNewest = response.data.find(item => item.version === process.version);
            if (npmNewestNext) {
                result.npmNewestNext = npmNewestNext.npm;
            }
            if (npmNewest) {
                result.npmNewest = npmNewest.npm;
            }

            const prefix = `system.host.${this.host}.versions`;

            await this.setForeignObjectNotExistsAsync(prefix, {
                type: 'channel',
                common: {
                    name: {
                        en: 'Node.js/Npm versions',
                        de: 'Node.js/Npm Versionen',
                        ru: 'Node.js/Npm версии',
                        pt: 'Versões Node.js/Npm',
                        nl: 'Node.js/Npm versions',
                        fr: 'Node.js/Npm versions',
                        it: 'Node.js/Npm versioni',
                        es: 'Node.js/Npm versiones',
                        pl: 'Wersja node.js/Npm',
                        'zh-cn': '页: 1',
                    },
                },
                native: {},
            });

            /** @type {ioBroker.SettableStateObject[]} */
            const states = [
                {
                    _id: 'nodeCurrent',
                    type: 'state',
                    common: {
                        role: 'state',
                        name: {
                            en: 'Current node.js version',
                            de: 'Aktuelle node.js Version',
                            ru: 'Текущая версия node.js',
                            pt: 'Versão atual do node.js',
                            nl: 'Current Node',
                            fr: 'Version actuelle node.js',
                            it: 'Versione attuale node.js',
                            es: 'Versión actual node.js',
                            pl: 'Aktualna wersja.js',
                            'zh-cn': '目前没有。',
                        },
                        type: 'string',
                        read: true,
                        write: false,
                        def: '',
                    },
                    native: {},
                },
                {
                    _id: 'nodeNewest',
                    type: 'state',
                    common: {
                        role: 'state',
                        name: {
                            en: 'Newest node.js version',
                            de: 'Neueste node.js Version',
                            ru: 'Новейшая версия node.js',
                            pt: 'Mais recente versão node.js',
                            nl: 'Nieuwste node',
                            fr: 'Nouvelle version node.js',
                            it: 'Nuova versione node.js',
                            es: 'Versión más reciente node.js',
                            pl: 'Najnowsza wersja węzła.js',
                            'zh-cn': '最新版本',
                        },
                        type: 'string',
                        read: true,
                        write: false,
                        def: '',
                    },
                    native: {},
                },
                {
                    _id: 'nodeNewestNext',
                    type: 'state',
                    common: {
                        role: 'state',
                        name: {
                            en: 'Newest next major node.js version',
                            de: 'Neueste nächste große node.js Version',
                            ru: 'Новейшая следующая версия node.js',
                            pt: 'Mais nova versão principal node.js',
                            nl: 'Nieuwste volgende grote node',
                            fr: 'Nouvelle prochaine version node.js',
                            it: 'Nuova versione principale node.js',
                            es: 'Versión más reciente node.js',
                            pl: 'Najnowsza wersja węzła.js',
                            'zh-cn': '今后最新的重要内容。',
                        },
                        type: 'string',
                        read: true,
                        write: false,
                        def: '',
                    },
                    native: {},
                },
                {
                    _id: 'npmCurrent',
                    type: 'state',
                    common: {
                        role: 'state',
                        name: {
                            en: 'Current npm version',
                            de: 'Aktuelle Version',
                            ru: 'Текущая версия npm',
                            pt: 'Versão actual npm',
                            nl: 'Current Npm versie',
                            fr: 'Version actuelle npm',
                            it: 'Versione npm attuale',
                            es: 'Versión actual npm',
                            pl: 'Aktualna wersja',
                            'zh-cn': '目前的印本',
                        },
                        type: 'string',
                        read: true,
                        write: false,
                        def: '',
                    },
                    native: {},
                },
                {
                    _id: 'npmNewest',
                    type: 'state',
                    common: {
                        role: 'state',
                        name: {
                            en: 'Newest npm version',
                            de: 'Neueste Version',
                            ru: 'Новейшая версия npm',
                            pt: 'Versão mais recente npm',
                            nl: 'Newest Npm versie',
                            fr: 'Nouvelle version npm',
                            it: 'Nuova versione npm',
                            es: 'Versión más reciente npm',
                            pl: 'Wersja nowa',
                            'zh-cn': '最新版本',
                        },
                        type: 'string',
                        read: true,
                        write: false,
                        def: '',
                    },
                    native: {},
                },
                {
                    _id: 'npmNewestNext',
                    type: 'state',
                    common: {
                        role: 'state',
                        name: {
                            en: 'Newest next major NPM version',
                            de: 'Neueste nächste große NPM-Version',
                            ru: 'Новейшая следующая крупная версия NPM',
                            pt: 'Mais nova versão principal do NPM',
                            nl: 'NPM',
                            fr: 'La version la plus récente',
                            it: 'Nuova versione NPM',
                            es: 'Versión NPM más reciente',
                            pl: 'Nowa wersja NPM',
                            'zh-cn': '下一次主要国家预防计划',
                        },
                        type: 'string',
                        read: true,
                        write: false,
                        def: '',
                    },
                    native: {},
                },
            ];

            for (const state of states) {
                await this.setForeignObjectNotExistsAsync(`${prefix}.${state._id}`, state);
            }
            const keys = Object.keys(result);
            for (let k = 0; k < keys.length; k++) {
                await this.setForeignStateAsync(`${prefix}.${keys[k]}`, result[keys[k]].replace(/^v/, ''), true);
            }
        } catch (error) {
            this.log.warn('Cannot check node.js/npm version');
        }
    }

    getData(callback) {
        this.log.info('requesting all objects');

        this.getObjectList({ include_docs: true }, (err, res) => {
            this.log.info('received all objects');
            if (res) {
                objects = {};
                let tmpPath = '';
                for (const row of res.rows) {
                    objects[row.doc._id] = row.doc;
                    if (row.doc.type === 'instance' && row.doc.common?.tmpPath) {
                        tmpPath && this.log.warn('tmpPath has multiple definitions!!');
                        tmpPath = row.doc.common.tmpPath;
                    }
                }

                // Some adapters want access on specified tmp directory
                if (tmpPath) {
                    this.config.tmpPath = tmpPath;
                    this.config.tmpPathAllow = true;
                }

                this.createUpdateInfo().then(() => this.writeUpdateInfo());
            }

            callback && callback(this);
        });
    }

    async checkRevokedVersions(repository) {
        try {
            const adapters = Object.keys(repository);
            const instances = await this.getObjectViewAsync('system', 'instance', {
                startkey: 'system.adapter.',
                endkey: 'system.adapter.\u9999',
            });

            for (const _adapter of adapters) {
                if (repository[_adapter].blockedVersions) {
                    // read current version
                    if (Array.isArray(repository[_adapter].blockedVersions)) {
                        const instance = instances.rows.find(
                            item => item.value?.common.name === _adapter && item.value.common.enabled
                        );
                        if (instance?.value?.common?.version) {
                            for (let i = 0; i < repository[_adapter].blockedVersions.length; i++) {
                                try {
                                    if (
                                        semver.satisfies(
                                            instance.value.common.version,
                                            repository[_adapter].blockedVersions[i]
                                        )
                                    ) {
                                        // stop all instances
                                        for (let k = 0; k < instances.rows.length; k++) {
                                            const obj = instances.rows[k].value;
                                            if (obj?.common.enabled && obj.common.name === _adapter) {
                                                obj.common.enabled = false;
                                                await this.setForeignObjectAsync(obj._id, obj);
                                                this.log.warn(
                                                    `Instance ${obj._id.replace(
                                                        'system.adapter.',
                                                        ''
                                                    )} was disabled because blocked. Please update ${_adapter} to newer or available version`
                                                );
                                                this.sendToHost(obj.common.host, 'addNotification', {
                                                    scope: 'system',
                                                    category: 'accessErrors', // change to 'blocked' when js-controller 4.1. released
                                                    instance: obj._id,
                                                    message: `Instance version was blocked. Please check for updates and update before restarting the instance`,
                                                });
                                            }
                                        }
                                    }
                                } catch (e) {
                                    this.log.error(
                                        `Cannot check revoked versions: ${repository[_adapter].blockedVersions[i]}`
                                    );
                                    // ignore
                                }
                            }
                        }
                    } else {
                        this.log.error(
                            `Invalid blockedVersions for ${_adapter}: ${JSON.stringify(
                                repository[_adapter].blockedVersions
                            )}. Expected array like ["<= 3.17.4"] or also ["~3.14.0", "~3.15.0", "~3.16.0"]`
                        );
                    }
                }
            }
        } catch (e) {
            this.log.error(`Cannot check revoked versions: ${e}`);
        }
    }

    // update icons by all known default objects. Remove this function after 2 years (BF: 2021.04.20)
    updateIcons() {
        if (fs.existsSync(`${utils.controllerDir}/io-package.json`)) {
            const ioPackage = require(`${utils.controllerDir}/io-package.json`);
            ioPackage.objects.forEach(async obj => {
                if (obj.common && obj.common.icon && obj.common.icon.length > 50) {
                    const cObj = await this.getForeignObjectAsync(obj._id);
                    if (cObj?.common && (!cObj.common.icon || cObj.common.icon.length < 50)) {
                        this.log.debug(`Update icon for ${cObj._id}`);
                        cObj.common.icon = obj.common.icon;
                        await this.setForeignObjectAsync(cObj._id, cObj);
                    }
                }
            });
        }
    }

    /**
     * Read repository information from active repository
     */
    updateRegister() {
        if (lastRepoUpdate && Date.now() - lastRepoUpdate < 3600000) {
            this.log.error('Automatic repository update is not allowed more than once a hour');
            if (this.config.autoUpdate) {
                this.timerRepo && clearTimeout(this.timerRepo);
                this.timerRepo = setTimeout(
                    () => {
                        this.timerRepo = null;
                        this.updateRegister();
                    },
                    this.config.autoUpdate * ONE_HOUR_MS + 1
                );
            }
            return;
        }

        lastRepoUpdate = Date.now();

        this.getForeignObject('system.config', (err, systemConfig) => {
            err && this.log.error('May not read "system.config"');

            if (systemConfig && systemConfig.common) {
                this.getForeignObject('system.repositories', (err, repos) => {
                    err && this.log.error('May not read "system.repositories"');
                    if (!repos || repos.ts === undefined) {
                        return;
                    }

                    // Check if repositories exist
                    let exists = false;
                    const active = systemConfig.common.activeRepo;

                    // if repo is valid and actual
                    if (
                        !err &&
                        repos?.native?.repositories?.[active] &&
                        Date.now() < repos.ts + this.config.autoUpdate * ONE_HOUR_MS
                    ) {
                        exists = true;
                    }

                    if (!exists) {
                        this.log.info('Request actual repository...');
                        // request repo from host
                        this.sendToHost(
                            /** @ts-expect-error */
                            this.host,
                            'getRepository',
                            {
                                repo: active,
                                update: true,
                            },
                            _repository => {
                                /** @ts-expect-error */
                                if (_repository === ERROR_PERMISSION) {
                                    this.log.error('May not read "getRepository"');
                                } else {
                                    this.log.info('Repository received successfully.');

                                    socket && socket.repoUpdated();
                                    this.checkRevokedVersions(_repository).then(() => {});
                                }

                                // start the next cycle
                                if (this.config.autoUpdate) {
                                    this.timerRepo && clearTimeout(this.timerRepo);
                                    this.log.debug(
                                        `Next repo update on ${new Date(
                                            Date.now() + this.config.autoUpdate * ONE_HOUR_MS + 1
                                        ).toLocaleString()}`
                                    );
                                    this.timerRepo = setTimeout(
                                        () => {
                                            this.timerRepo = null;
                                            this.updateRegister();
                                        },
                                        this.config.autoUpdate * ONE_HOUR_MS + 1
                                    );
                                }
                            }
                        );
                    } else if (this.config.autoUpdate) {
                        let interval = repos.ts + this.config.autoUpdate * ONE_HOUR_MS - Date.now() + 1;
                        if (interval > 0x7fffffff) {
                            interval = 0x7fffffff;
                        }
                        this.log.debug(`Next repo update on ${new Date(Date.now() + interval).toLocaleString()}`);
                        this.timerRepo && clearTimeout(this.timerRepo);
                        this.timerRepo = setTimeout(() => {
                            this.timerRepo = null;
                            this.updateRegister();
                        }, interval);
                    }
                });
            }
        });
    }

    /**
     * Initialize the adapter
     */
    init() {
        this.config.defaultUser = this.config.defaultUser || 'admin';
        if (!this.config.defaultUser.match(/^system\.user\./)) {
            this.config.defaultUser = `system.user.${this.config.defaultUser}`;
        }

        this.getData(
            adapter => (webServer = new Web(adapter.config, adapter, this.initSocket.bind(this), { systemLanguage }))
        );

        if (
            this.config.accessApplyRights &&
            this.config.accessLimit &&
            !this.config.auth &&
            this.config.defaultUser !== 'system.user.admin'
        ) {
            this.applyRights();
        }

        // By default, update repository every 24 hours
        if (this.config.autoUpdate === undefined || this.config.autoUpdate === null) {
            this.config.autoUpdate = 24;
        }

        // interval in hours
        /** @ts-expect-error */
        this.config.autoUpdate = parseInt(this.config.autoUpdate, 10) || 0;
        if (this.config.autoUpdate && this.config.autoUpdate < 4) {
            this.config.autoUpdate = 4; // only every 4 hours is minimal update interval
        } else if (this.config.autoUpdate > 590) {
            // 0x7FFFFFFF / ONE_HOUR_MS = 596
            this.config.autoUpdate = 590; // max interval is 2147483647 milliseconds
        }

        // check info.connected
        this.getObjectAsync('info.connected').then(obj => {
            if (!obj) {
                const packageJson = JSON.parse(fs.readFileSync(`${__dirname}/io-package.json`).toString('utf8'));
                const obj = packageJson.instanceObjects.find(o => o._id === 'info.connected');
                if (obj) {
                    return this.setObjectAsync(obj._id, obj);
                }
            }
        });

        this.config.autoUpdate && this.updateRegister();

        this.updateNews();
        this.updateIcons();
        this.validateUserData0();
    }

    /**
     * Create 0_userdata if it does not exist
     */
    validateUserData0() {
        this.getForeignObject('0_userdata.0', (err, obj) => {
            if (!obj) {
                try {
                    const ioContent = fs.readFileSync(`${utils.controllerDir}/io-package.json`).toString('utf8');
                    const io = JSON.parse(ioContent);
                    if (io.objects) {
                        const userData = io.objects.find(obj => obj._id === '0_userdata.0');
                        if (userData) {
                            this.setForeignObject(userData._id, userData, () =>
                                this.log.info('Object 0_userdata.0 was re-created')
                            );
                        }
                    }
                } catch (e) {
                    this.log.error(`Cannot read ${utils.controllerDir}/io-package.json: ${e}`);
                }
            }
        });
    }
}

if (require.main !== module) {
    // Export the constructor in compact mode
    module.exports = options => new Admin(options);
} else {
    // otherwise start the instance directly
    (() => new Admin())();
}
