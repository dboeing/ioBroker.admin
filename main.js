/**
 *      Admin backend
 *
 *      Controls Adapter-Processes
 *
 *      Copyright 2014-2023 bluefox <dogafox@gmail.com>,
 *      MIT License
 *
 */

/* jshint -W097 */
/* jshint strict: false */
/* jslint node: true */
'use strict';

const semver = require('semver');
const axios = require('axios');
const fs = require('fs');
const cp = require('child_process');

const utils = require('@iobroker/adapter-core'); // Get common adapter utils
const getInstalledInfo = utils.commonTools.getInstalledInfo;
const SocketAdmin = require('@iobroker/socket-classes').SocketAdmin;
const ws = require('@iobroker/ws-server');

const adapterName = require('./package.json').name.split('.').pop();
const Web = require('./lib/web');

const ONE_HOUR_MS = 3_600_000;
const ERROR_PERMISSION = 'permissionError';

const CURRENT_MAX_MAJOR_NODEJS = 18;
const CURRENT_MAX_MAJOR_NPM = 8;

let uuid = '';
let socket = null;
let webServer = null;
let lastRepoUpdate = null;

let objects = {};
let secret = 'Zgfr56gFe87jJOM'; // Will be generated by first start
let adapter;
let systemLanguage = 'en';

function startAdapter(options) {
    options = options || {};
    Object.assign(options, {
        name: adapterName, // adapter name
        dirname: __dirname, // say own position
        logTransporter: true, // receive the logs
        systemConfig: true,
        install: callback => typeof callback === 'function' && callback(),
    });

    adapter = new utils.Adapter(options);

    adapter.on('objectChange', (id, obj) => {
        if (obj) {
            // console.log('objectChange: ' + id);
            objects[id] = obj;

            if (id === 'system.config' && !adapter.config.language) {
                if (obj.common && obj.common.language) {
                    systemLanguage = obj.common.language;
                    webServer && webServer.setLanguage(systemLanguage);
                }
            }

            if (id === 'system.repositories' || id.match(/^system\.adapter\.[^.]+$/)) {
                adapter.updaterTimeout && clearTimeout(adapter.updaterTimeout);
                adapter.updaterTimeout = setTimeout(() => {
                    adapter.updaterTimeout = null;
                    writeUpdateInfo(adapter);
                }, 5000);
            }
        } else {
            // console.log('objectDeleted: ' + id);
            if (objects[id]) {
                delete objects[id];
            }
        }

        // TODO Build in some threshold of messages
        socket && socket.objectChange(id, obj);
    });

    adapter.on('stateChange', (id, state) => socket && socket.stateChange(id, state));

    adapter.on('fileChange', (id, fileName, size) => socket && socket.fileChange(id, fileName, size));

    adapter.on('ready', () =>
        adapter.getForeignObject('system.config', (err, obj) => {
            if (!err && obj) {
                obj.native = obj.native || {};
                if (adapter.config.language) {
                    systemLanguage = adapter.config.language;
                } else if (obj.common && obj.common.language) {
                    systemLanguage = obj.common.language;
                }

                if (!obj.native.secret) {
                    require('crypto').randomBytes(24, (ex, buf) => {
                        adapter.config.secret = buf.toString('hex');
                        adapter.extendForeignObject('system.config', { native: { secret: adapter.config.secret } });
                        main(adapter);
                    });
                } else {
                    adapter.config.secret = obj.native.secret;
                    main(adapter);
                }
            } else {
                adapter.config.secret = secret;
                adapter.log.error('Cannot find object system.config');
            }

            // adapter.subscribeForeignFiles('*', '*');
        })
    );

    adapter.on('message', obj => {
        if (!obj) {
            return false;
        }
        if (obj.command === 'checkFiles') {
            if (typeof obj.message === 'string') {
                try {
                    return (
                        obj.callback &&
                        adapter.sendTo(obj.from, obj.command, { result: fs.existsSync(obj.message) }, obj.callback)
                    );
                } catch (e) {
                    return obj.callback && adapter.sendTo(obj.from, obj.command, { error: e.message }, obj.callback);
                }
            } else if (Array.isArray(obj.message)) {
                const result = {};
                for (let f = 0; f < obj.message.length; f++) {
                    try {
                        result[obj.message[f]] = fs.existsSync(obj.message[f]);
                    } catch (e) {
                        result[obj.message[f]] = e.message;
                    }
                }
                return obj.callback && adapter.sendTo(obj.from, obj.command, result, obj.callback);
            }
        } else if (obj.command === 'autocomplete') {
            // just for test
            return (
                obj.callback &&
                adapter.sendTo(
                    obj.from,
                    obj.command,
                    [
                        { value: 1, label: 'first' },
                        { value: 2, label: 'second' },
                    ],
                    obj.callback
                )
            );
        } else if (obj.command === 'selectSendTo') {
            adapter.log.info(`SelectSendTo: ${JSON.stringify(obj.message)}`);
            // just for test
            return (
                obj.callback &&
                adapter.sendTo(
                    obj.from,
                    obj.command,
                    [
                        { label: 'Afghanistan', value: 'AF' },
                        { label: 'Åland Islands', value: 'AX' },
                        { label: 'Albania', value: 'AL' },
                    ],
                    obj.callback
                )
            );
        } else if (obj.command === 'url') {
            adapter.log.info(`url: ${JSON.stringify(obj.message)}`);
            // just for test
            return (
                obj.callback &&
                adapter.sendTo(obj.from, obj.command, { openUrl: obj.message._origin, saveConfig: true }, obj.callback)
            );
        }

        socket && socket.sendCommand(obj);

        return true;
    });

    adapter.on('unload', callback => {
        adapter.timerRepo && clearTimeout(adapter.timerRepo);
        adapter.timerRepo = null;

        adapter.timerNews && clearTimeout(adapter.timerNews);
        adapter.timerNews = null;

        adapter.ratingTimeout && clearTimeout(adapter.ratingTimeout);
        adapter.ratingTimeout = null;

        adapter.updaterTimeout && clearTimeout(adapter.updaterTimeout);
        adapter.updaterTimeout = null;

        try {
            adapter.log.info(
                `terminating http${adapter.config.secure ? 's' : ''} server on port ${adapter.config.port}`
            );
            socket && socket.close();
            webServer.close();
            callback();
        } catch (e) {
            callback();
        }
    });

    // obj = {message: msg, severity: level, from: this.namespace, ts: (new Date()).getTime()}
    adapter.on('log', obj => socket && socket.sendLog(obj));

    return adapter;
}

function createUpdateInfo(adapter) {
    const promises = [];
    // create connected object and state
    let updatesNumberObj = objects[`${adapter.namespace}.info.updatesNumber`];

    if (!updatesNumberObj || !updatesNumberObj.common || updatesNumberObj.common.type !== 'number') {
        let obj = {
            _id: 'info.updatesNumber',
            type: 'state',
            common: {
                role: 'indicator.updates',
                name: {
                    en: 'Number of adapters to update',
                    de: 'Anzahl der zu aktualisierenden Adapter',
                    ru: 'Количество адаптеров для обновления',
                    pt: 'Número de adaptadores para atualizar',
                    nl: 'Aantal adapters om te updaten',
                    fr: "Nombre d'adaptateurs à mettre à jour",
                    it: 'Numero di adattatori da aggiornare',
                    es: 'Número de adaptadores para actualizar',
                    pl: 'Liczba adapterów do aktualizacji',
                    'zh-cn': '要更新的适配器数量',
                },
                type: 'number',
                read: true,
                write: false,
                def: 0,
            },
            native: {},
        };

        adapter.setObject(obj._id, obj);
    }

    let updatesListObj = objects[`${adapter.namespace}.info.updatesList`];

    if (!updatesListObj || !updatesListObj.common || updatesListObj.common.type !== 'string') {
        let obj = {
            _id: 'info.updatesList',
            type: 'state',
            common: {
                role: 'indicator.updates',
                name: {
                    en: 'List of adapters to update',
                    de: 'Liste der zu aktualisierenden Adapter',
                    ru: 'Список адаптеров для обновления',
                    pt: 'Lista de adaptadores para atualizar',
                    nl: 'Lijst met adapters die moeten worden bijgewerkt',
                    fr: 'Liste des adaptateurs à mettre à jour',
                    it: 'Elenco degli adattatori da aggiornare',
                    es: 'Lista de adaptadores para actualizar',
                    pl: 'Lista adapterów do aktualizacji',
                    'zh-cn': '要更新的适配器列表',
                },
                type: 'string',
                read: true,
                write: false,
                def: '',
            },
            native: {},
        };

        adapter.setObject(obj._id, obj);
    }

    let newUpdatesObj = objects[`${adapter.namespace}.info.newUpdates`];

    if (!newUpdatesObj || !newUpdatesObj.common || newUpdatesObj.common.type !== 'boolean') {
        let obj = {
            _id: 'info.newUpdates',
            type: 'state',
            common: {
                role: 'indicator.updates',
                name: {
                    en: 'Indicator if new adapter updates are available',
                    de: 'Anzeige, ob neue Adapter-Updates verfügbar sind',
                    ru: 'Индикатор наличия новых обновлений адаптера',
                    pt: 'Indicador se novas atualizações do adaptador estão disponíveis',
                    nl: 'Indicator of er nieuwe adapter-updates beschikbaar zijn',
                    fr: "Indicateur si de nouvelles mises à jour de l'adaptateur sont disponibles",
                    it: "Indicatore se sono disponibili nuovi aggiornamenti dell'adattatore",
                    es: 'Indicador si hay nuevas actualizaciones de adaptadores disponibles',
                    pl: 'Wskaźnik, czy dostępne są nowe aktualizacje adaptera',
                    'zh-cn': '指示是否有新的适配器更新可用',
                },
                type: 'boolean',
                read: true,
                write: false,
                def: false,
            },
            native: {},
        };

        promises.push(adapter.setObjectAsync(obj._id, obj));
    }

    let updatesJsonObj = objects[`${adapter.namespace}.info.updatesJson`];

    if (!updatesJsonObj || !updatesJsonObj.common || updatesJsonObj.common.type !== 'string') {
        let obj = {
            _id: 'info.updatesJson',
            type: 'state',
            common: {
                role: 'indicator.updates',
                name: {
                    en: 'JSON string with adapter update information',
                    de: 'JSON-String mit Adapteraktualisierungsinformationen',
                    ru: 'Строка JSON с информацией об обновлении адаптера',
                    pt: 'String JSON com informações de atualização do adaptador',
                    nl: 'JSON-tekenreeks met adapter-update-informatie',
                    fr: "Chaîne JSON avec les informations de mise à jour de l'adaptateur",
                    it: "Stringa JSON con informazioni sull'aggiornamento dell'adattatore",
                    es: 'Cadena JSON con información de actualización del adaptador',
                    pl: 'Ciąg JSON z informacjami o aktualizacji adaptera',
                    'zh-cn': '带有适配器更新信息的 JSON 字符串',
                },
                type: 'string',
                read: true,
                write: false,
                def: '{}',
            },
            native: {},
        };

        promises.push(adapter.setObjectAsync(obj._id, obj));
    }

    let lastUpdateCheckObj = objects[`${adapter.namespace}.info.lastUpdateCheck`];

    if (!lastUpdateCheckObj || !lastUpdateCheckObj.common || lastUpdateCheckObj.common.type !== 'number') {
        let obj = {
            _id: 'info.lastUpdateCheck',
            type: 'state',
            common: {
                role: 'value.time',
                name: {
                    en: 'Timestamp of last update check',
                    de: 'Zeitstempel der letzten UpdatePrüfung',
                    ru: 'Отметка времени последней проверки обнвлений',
                    pt: 'Timestamp da última verificação de atualizaçã',
                    nl: 'Tijdstempel van laatste updatecontrole',
                    fr: 'Horodatage de la dernière vérificationde mise à jour',
                    it: "Timestamp dell'ultimo controllo di aggiornamento",
                    es: 'Marca de tiempo de la última verificación de actalización',
                    pl: 'Znacznik czasu ostatniego sprawdzenia aktualizacji',
                    'zh-cn': '上次更新检查的时间戳',
                },
                type: 'number',
                read: true,
                write: false,
                def: 0,
            },
            native: {},
        };

        promises.push(adapter.setObjectAsync(obj._id, obj));
    }

    return Promise.all(promises);
}

// Helper methods
function upToDate(v1, v2) {
    return semver.gt(v2, v1);
}

function writeUpdateInfo(adapter, sources) {
    if (!objects['system.config'] || !objects['system.config'].common) {
        return adapter.log.warn('Repository cannot be read. Invalid "system.config" object.');
    }
    const activeRepo = objects['system.config'].common.activeRepo;
    const systemRepos = objects['system.repositories'];

    if (!sources) {
        sources = {};

        // If multi-repo case
        if (Array.isArray(activeRepo)) {
            if (systemRepos && systemRepos.native && systemRepos.native.repositories) {
                activeRepo.forEach(repo => {
                    if (systemRepos.native.repositories[repo] && systemRepos.native.repositories[repo].json) {
                        Object.assign(sources, systemRepos.native.repositories[repo].json);
                    } else {
                        adapter.setState('info.updatesNumber', 0, true);
                        adapter.setState('info.updatesList', '', true);
                        adapter.setState('info.newUpdates', false, true);
                        adapter.setState('info.updatesJson', '{}', true);
                        adapter.setState('info.lastUpdateCheck', Date.now(), true);
                        if (systemRepos.native.repositories[activeRepo]) {
                            adapter.log.warn(`Repository cannot be read: Active repo - ${activeRepo}`);
                        } else {
                            adapter.log.warn('No repository source configured');
                        }
                    }
                });
            }
        } else if (
            systemRepos &&
            systemRepos.native &&
            systemRepos.native.repositories &&
            systemRepos.native.repositories[activeRepo] &&
            systemRepos.native.repositories[activeRepo].json
        ) {
            sources = systemRepos.native.repositories[activeRepo].json;
        }
    }

    if (!Object.keys(sources).length) {
        adapter.setState('info.updatesNumber', 0, true);
        adapter.setState('info.updatesList', '', true);
        adapter.setState('info.newUpdates', false, true);
        adapter.setState('info.updatesJson', '{}', true);
        adapter.setState('info.lastUpdateCheck', Date.now(), true);
        if (Array.isArray(activeRepo)) {
            let found = false;
            if (systemRepos && systemRepos.native && systemRepos.native.repositories) {
                activeRepo.forEach(repo => {
                    if (systemRepos.native.repositories[activeRepo]) {
                        adapter.log.warn(`Active repository "${repo}" cannot be read`);
                        found = true;
                    }
                });
            }
            !found &&
                adapter.log.warn(
                    `No repository source configured. Possible values: ${
                        systemRepos && systemRepos.native && systemRepos.native.repositories
                            ? Object.keys(systemRepos.native.repositories).join(', ')
                            : 'none'
                    }. Active repo(s): "${activeRepo.join('", "')}"`
                );
        } else {
            if (
                systemRepos &&
                systemRepos.native &&
                systemRepos.native.repositories &&
                systemRepos.native.repositories[activeRepo]
            ) {
                adapter.log.warn(`Repository cannot be read. Active repo: ${activeRepo}`);
            } else {
                adapter.log.warn(
                    `No repository source configured. Possible values: ${
                        systemRepos && systemRepos.native && systemRepos.native.repositories
                            ? Object.keys(systemRepos.native.repositories).join(', ')
                            : 'none'
                    }. Active repo: "${activeRepo}"`
                );
            }
        }
        return;
    }

    let installed = getInstalledInfo();
    let list = [];
    let updatesJson = {};
    let newUpdateIndicator = false;

    adapter.getState('info.updatesJson', (err, state) => {
        let oldUpdates;
        if (state && state.val) {
            oldUpdates = JSON.parse(state.val) || {};
        } else {
            oldUpdates = {};
        }

        Object.keys(sources).forEach(name => {
            try {
                if (installed[name] && installed[name].version && sources[name].version) {
                    if (
                        sources[name].version !== installed[name].version &&
                        !upToDate(sources[name].version, installed[name].version)
                    ) {
                        // Check if updates are new or already known to user
                        if (
                            !oldUpdates ||
                            !oldUpdates[name] ||
                            oldUpdates[name].availableVersion !== sources[name].version
                        ) {
                            newUpdateIndicator = true;
                        } // endIf
                        updatesJson[name] = {
                            availableVersion: sources[name].version,
                            installedVersion: installed[name].version,
                        };
                        // remove first part of the name
                        const n = name.indexOf('.');
                        list.push(n === -1 ? name : name.substring(n + 1));
                    }
                }
            } catch (err) {
                adapter.log.warn(`Error on version check for ${name}: ${err}`);
            }
        });

        adapter.setState('info.updatesNumber', list.length, true);
        adapter.setState('info.updatesList', list.join(', '), true);
        adapter.setState('info.newUpdates', newUpdateIndicator, true);
        adapter.setState('info.updatesJson', JSON.stringify(updatesJson), true);
        adapter.setState('info.lastUpdateCheck', Date.now(), true);
    });
}

function initSocket(server, store, adapter) {
    socket = new SocketAdmin(adapter.config, adapter, objects);
    socket.start(server, ws, {
        userKey: 'connect.sid',
        store,
        secret: adapter.config.secret,
    });

    // subscribe on all object changes
    socket.subscribe('objectChange', '*');

    adapter
        .getForeignObjectAsync('system.meta.uuid')
        .then(async obj => {
            if (obj && obj.native) {
                uuid = obj.native.uuid;
                try {
                    await socket.updateRatings();
                } catch (error) {
                    adapter.log.error(`Cannot fetch ratings: ${error}`);
                }
            }
        })
        .catch(error => adapter.log.error(`Cannot read UUID: ${error}`));
}

function processTasks(adapter) {
    if (!adapter._running && adapter._tasks.length) {
        adapter._running = true;

        const obj = adapter._tasks.shift();
        if (!obj.acl || obj.acl.owner !== adapter.config.defaultUser) {
            obj.acl.owner = adapter.config.defaultUser;
            adapter.setForeignObject(obj._id, obj, err =>
                setImmediate(() => {
                    adapter._running = false;
                    processTasks(adapter);
                })
            );
        } else {
            setImmediate(() => {
                adapter._running = false;
                processTasks(adapter);
            });
        }
    }
}

function applyRightsToObjects(adapter, pattern, types, cb) {
    if (typeof types === 'object') {
        let count = types.length;
        types.forEach(type => applyRightsToObjects(adapter, pattern, type, () => !--count && cb && cb()));
    } else {
        adapter.getObjectView('system', types, { startkey: `${pattern}.`, endkey: `${pattern}.\u9999` }, (err, doc) => {
            adapter._tasks = adapter._tasks || [];

            if (!err && doc.rows.length) {
                for (let i = 0; i < doc.rows.length; i++) {
                    adapter._tasks.push(doc.rows[i].value);
                }
                processTasks(adapter);
            }
        });
    }
}

function applyRights(adapter) {
    const promises = [];
    adapter.config.accessAllowedConfigs = adapter.config.accessAllowedConfigs || [];
    adapter.config.accessAllowedTabs = adapter.config.accessAllowedTabs || [];

    adapter.config.accessAllowedConfigs.forEach(id =>
        promises.push(
            new Promise(resolve =>
                adapter.getForeignObject(`system.adapter.${id}`, (err, obj) => {
                    if (obj && obj.acl && obj.acl.owner !== adapter.config.defaultUser) {
                        obj.acl.owner = adapter.config.defaultUser;
                        adapter.setForeignObject(`system.adapter.${id}`, obj, err => resolve(!err));
                    } else {
                        resolve(false);
                    }
                })
            )
        )
    );

    adapter.config.accessAllowedTabs.forEach(id => {
        if (id.startsWith('devices.')) {
            // change rights of all alias.*
            applyRightsToObjects(adapter, 'alias', ['state', 'channel']);
        } else if (id.startsWith('javascript.')) {
            // change rights of all script.js.*
            applyRightsToObjects(adapter, 'javascript', ['script', 'channel']);
        } else if (id.startsWith('fullcalendar.')) {
            // change rights of all fullcalendar.*
            applyRightsToObjects(adapter, 'fullcalendar', ['schedule']);
        } else if (id.startsWith('scenes.')) {
            // change rights of all scenes.*
            applyRightsToObjects(adapter, 'scenes', ['state', 'channel']);
        }
    });

    Promise.all(promises).then(results => {
        const len = results.filter(r => !!r).length;
        len && adapter.log.info(`Updated ${len} objects`);
    });
}

// read news from server
function updateNews() {
    adapter.timerNews && clearTimeout(adapter.timerNews);
    adapter.timerNews = null;

    checkNodeJsVersion().catch(e => adapter.log.warn(`Cannot check node.js versions: ${e}`));

    let oldEtag;
    let newNews;
    let oldNews;
    let originalOldNews;
    let newEtag;

    return adapter
        .getStateAsync('info.newsETag')
        .then(state => {
            oldEtag = state && state.val;
            return axios
                .get('https://iobroker.live/repo/news-hash.json', {
                    timeout: 13000,
                    validateStatus: status => status < 400,
                })
                .then(response => response.data)
                .catch(error =>
                    adapter.log.warn(
                        `Cannot update news: ${error.response ? error.response.data : error.message || error.code}`
                    )
                );
        })
        .then(etag => {
            if (etag && etag.hash !== oldEtag) {
                newEtag = etag.hash;
                return axios
                    .get('https://iobroker.live/repo/news.json', {
                        timeout: 14000,
                        validateStatus: status => status < 400,
                    })
                    .then(response => response.data)
                    .catch(error =>
                        adapter.log.warn(
                            `Cannot update news_: ${error.response ? error.response.data : error.message || error.code}`
                        )
                    );
            } else {
                newEtag = oldEtag;
                return Promise.resolve([]);
            }
        })
        .then(_newNews => {
            newNews = _newNews || [];
            return adapter.getStateAsync('info.newsFeed');
        })
        .then(state => {
            try {
                oldNews = state && state.val ? JSON.parse(state.val) : [];
            } catch (e) {
                oldNews = [];
            }
            originalOldNews = JSON.stringify(oldNews);

            return adapter.getStateAsync('info.newsLastId');
        })
        .then(lastState => {
            // find time of last ID
            let time = '';
            if (lastState && lastState.val) {
                const item = oldNews.find(item => item.id === lastState.val);
                if (item) {
                    time = item.created;
                }
            }

            // add all IDs newer than last seen
            newNews.forEach(item => {
                if (!lastState || !time || item.created > time) {
                    if (!oldNews.find(it => it.created === item.created)) {
                        oldNews.push(item);
                    }
                }
            });

            oldNews.sort((a, b) => (a.created > b.created ? -1 : a.created < b.created ? 1 : 0));

            // delete news older than 3 months
            let i;
            for (i = oldNews.length - 1; i >= 0; i--) {
                if (Date.now() - new Date(oldNews[i].created).getTime() > 180 * 24 * 3600000) {
                    oldNews.splice(i, 1);
                }
            }

            if (originalOldNews !== JSON.stringify(oldNews)) {
                return adapter.setStateAsync('info.newsFeed', JSON.stringify(oldNews), true);
            } else {
                return Promise.resolve();
            }
        })
        .then(() => (newEtag !== oldEtag ? adapter.setStateAsync('info.newsETag', newEtag, true) : Promise.resolve()))
        .catch(e => adapter.log.error(`Cannot update news: ${e}`))
        .then(() => (adapter.timerNews = setTimeout(() => updateNews(), 24 * ONE_HOUR_MS + 1)));
}

function main(adapter) {
    // adapter.subscribeForeignStates('*');
    // adapter.subscribeForeignObjects('*');

    adapter.config.defaultUser = adapter.config.defaultUser || 'admin';
    if (!adapter.config.defaultUser.match(/^system\.user\./)) {
        adapter.config.defaultUser = `system.user.${adapter.config.defaultUser}`;
    }

    if (adapter.config.secure) {
        // Load certificates
        adapter.getCertificates((err, certificates, leConfig) => {
            adapter.config.certificates = certificates;
            adapter.config.leConfig = leConfig;

            getData(adapter, adapter => (webServer = new Web(adapter.config, adapter, initSocket, { systemLanguage })));
        });
    } else {
        getData(adapter, adapter => (webServer = new Web(adapter.config, adapter, initSocket, { systemLanguage })));
    }

    if (
        adapter.config.accessApplyRights &&
        adapter.config.accessLimit &&
        !adapter.config.auth &&
        adapter.config.defaultUser !== 'system.user.admin'
    ) {
        applyRights(adapter);
    }

    // By default, update repository every 24 hours
    if (adapter.config.autoUpdate === undefined || adapter.config.autoUpdate === null) {
        adapter.config.autoUpdate = 24;
    }

    // interval in hours
    adapter.config.autoUpdate = parseInt(adapter.config.autoUpdate, 10) || 0;
    if (adapter.config.autoUpdate && adapter.config.autoUpdate < 4) {
        adapter.config.autoUpdate = 4; // only every 4 hours is minimal update interval
    } else if (adapter.config.autoUpdate > 590) {
        // 0x7FFFFFFF / ONE_HOUR_MS = 596
        adapter.config.autoUpdate = 590; // max interval is 2147483647 milliseconds
    }

    // check info.connected
    adapter.getObjectAsync('info.connected').then(obj => {
        if (!obj) {
            let packageJson = JSON.parse(fs.readFileSync(`${__dirname}/io-package.json`).toString('utf8'));
            const obj = packageJson.instanceObjects.find(o => o._id === 'info.connected');
            if (obj) {
                return adapter.setObjectAsync(obj._id, obj);
            }
        }
    });

    adapter.config.autoUpdate && updateRegister();

    updateNews();
    updateIcons();
    validateUserData0();
}
// create 0_userdata if it does not exist
function validateUserData0() {
    adapter.getForeignObject('0_userdata.0', (err, obj) => {
        if (!obj) {
            try {
                let io = fs.readFileSync(`${utils.controllerDir}/io-package.json`).toString('utf8');
                io = JSON.parse(io);
                if (io.objects) {
                    const userData = io.objects.find(obj => obj._id === '0_userdata.0');
                    if (userData) {
                        adapter.setForeignObject(userData._id, userData, err =>
                            adapter.log.info('Object 0_userdata.0 was re-created')
                        );
                    }
                }
            } catch (e) {
                adapter.log.error(`Cannot read ${utils.controllerDir}/io-package.json: ${e}`);
            }
        }
    });
}

function getNpmVersion() {
    return new Promise((resolve, reject) => {
        const child = cp.exec('npm --version --location=global');

        const chunks = [];
        child.stdout.on('data', data => chunks.push(data.toString()));

        child.on('exit', (code /* , signal */) => {
            // try to analyse answer
            const lines = chunks.join('').split('\n');
            // npm WARN config global `--global`, `--local` are deprecated. Use `--location=global` instead.
            // 6.14.16
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().match(/^\d+\.\d+\.\d+/)) {
                    return resolve(lines[i].trim());
                }
            }
            reject('Cannot find npm version');
        });
    });
}

async function checkNodeJsVersion() {
    if (adapter.supportsFeature('CONTROLLER_NODE_VERSION_CHECK')) {
        return;
    }
    // allow only one admin instance to check the versions for every host
    if (adapter.instance !== 0) {
        const objs = await adapter.getObjectViewAsync('system', 'instance', {
            startkey: 'system.adapter.admin.',
            endkey: 'system.adapter.admin.\u9999',
        });
        let min = null;
        // find the lowest active instance on the same host
        for (let i = 0; i < objs.rows.length; i++) {
            const obj = objs.rows[i].value;
            if (obj.common.enabled && obj.common.host === adapter.common.host) {
                const instance = parseInt(objs.rows[i].id.split('.').pop());
                if (min === null || min < instance) {
                    min = instance;
                }
            }
        }
        if (adapter.instance !== min) {
            return;
        }
    }

    const response = await axios('https://nodejs.org/download/release/index.json');
    const result = {
        nodeNewest: '',
        nodeNewestNext: '',
        npmNewest: '',
        npmNewestNext: '',
        npmCurrent: '',
        nodeCurrent: process.version,
    };

    try {
        result.npmCurrent = await getNpmVersion();
    } catch (error) {
        adapter.log.warn(`Cannot get current npm version: ${error}`);
    }

    // https://nodejs.org/download/release/index.json
    // detect new version of the same major version and new major version (that is allowed by ioBroker)
    try {
        // find newest suggested version
        const nodeNewestNext = response.data.find(item => item.version.startsWith(`v${CURRENT_MAX_MAJOR_NODEJS}.`));
        const nodeCurrentMajor = process.version.split('.')[0];
        const nodeNewest = response.data.find(item => item.version.startsWith(`${nodeCurrentMajor}.`));
        if (nodeNewestNext) {
            result.nodeNewestNext = nodeNewestNext.version;
        }
        if (nodeNewest) {
            result.nodeNewest = nodeNewest.version;
        }

        // find newest suggested version
        const npmNewestNext =
            nodeNewestNext || response.data.find(item => item.npm.startsWith(`${CURRENT_MAX_MAJOR_NPM}.`));
        const npmNewest = response.data.find(item => item.version === process.version);
        if (npmNewestNext) {
            result.npmNewestNext = npmNewestNext.npm;
        }
        if (npmNewest) {
            result.npmNewest = npmNewest.npm;
        }

        const prefix = `system.host.${adapter.common.host}.versions`;

        await adapter.setForeignObjectNotExistsAsync(prefix, {
            type: 'channel',
            common: {
                name: {
                    en: 'Node.js/Npm versions',
                    de: 'Node.js/Npm Versionen',
                    ru: 'Node.js/Npm версии',
                    pt: 'Versões Node.js/Npm',
                    nl: 'Node.js/Npm versions',
                    fr: 'Node.js/Npm versions',
                    it: 'Node.js/Npm versioni',
                    es: 'Node.js/Npm versiones',
                    pl: 'Wersja node.js/Npm',
                    'zh-cn': '页: 1',
                },
            },
        });
        const states = [
            {
                _id: 'nodeCurrent',
                type: 'state',
                common: {
                    role: 'state',
                    value: {
                        en: 'Current node.js version',
                        de: 'Aktuelle node.js Version',
                        ru: 'Текущая версия node.js',
                        pt: 'Versão atual do node.js',
                        nl: 'Current Node',
                        fr: 'Version actuelle node.js',
                        it: 'Versione attuale node.js',
                        es: 'Versión actual node.js',
                        pl: 'Aktualna wersja.js',
                        'zh-cn': '目前没有。',
                    },
                    type: 'string',
                    read: true,
                    write: false,
                    def: '',
                },
                native: {},
            },
            {
                _id: 'nodeNewest',
                type: 'state',
                common: {
                    role: 'state',
                    value: {
                        en: 'Newest node.js version',
                        de: 'Neueste node.js Version',
                        ru: 'Новейшая версия node.js',
                        pt: 'Mais recente versão node.js',
                        nl: 'Nieuwste node',
                        fr: 'Nouvelle version node.js',
                        it: 'Nuova versione node.js',
                        es: 'Versión más reciente node.js',
                        pl: 'Najnowsza wersja węzła.js',
                        'zh-cn': '最新版本',
                    },
                    type: 'string',
                    read: true,
                    write: false,
                    def: '',
                },
                native: {},
            },
            {
                _id: 'nodeNewestNext',
                type: 'state',
                common: {
                    role: 'state',
                    value: {
                        en: 'Newest next major node.js version',
                        de: 'Neueste nächste große node.js Version',
                        ru: 'Новейшая следующая версия node.js',
                        pt: 'Mais nova versão principal node.js',
                        nl: 'Nieuwste volgende grote node',
                        fr: 'Nouvelle prochaine version node.js',
                        it: 'Nuova versione principale node.js',
                        es: 'Versión más reciente node.js',
                        pl: 'Najnowsza wersja węzła.js',
                        'zh-cn': '今后最新的重要内容。',
                    },
                    type: 'string',
                    read: true,
                    write: false,
                    def: '',
                },
                native: {},
            },
            {
                _id: 'npmCurrent',
                type: 'state',
                common: {
                    role: 'state',
                    value: {
                        en: 'Current npm version',
                        de: 'Aktuelle Version',
                        ru: 'Текущая версия npm',
                        pt: 'Versão actual npm',
                        nl: 'Current Npm versie',
                        fr: 'Version actuelle npm',
                        it: 'Versione npm attuale',
                        es: 'Versión actual npm',
                        pl: 'Aktualna wersja',
                        'zh-cn': '目前的印本',
                    },
                    type: 'string',
                    read: true,
                    write: false,
                    def: '',
                },
                native: {},
            },
            {
                _id: 'npmNewest',
                type: 'state',
                common: {
                    role: 'state',
                    value: {
                        en: 'Newest npm version',
                        de: 'Neueste Version',
                        ru: 'Новейшая версия npm',
                        pt: 'Versão mais recente npm',
                        nl: 'Newest Npm versie',
                        fr: 'Nouvelle version npm',
                        it: 'Nuova versione npm',
                        es: 'Versión más reciente npm',
                        pl: 'Wersja nowa',
                        'zh-cn': '最新版本',
                    },
                    type: 'string',
                    read: true,
                    write: false,
                    def: '',
                },
                native: {},
            },
            {
                _id: 'npmNewestNext',
                type: 'state',
                common: {
                    role: 'state',
                    value: {
                        en: 'Newest next major NPM version',
                        de: 'Neueste nächste große NPM-Version',
                        ru: 'Новейшая следующая крупная версия NPM',
                        pt: 'Mais nova versão principal do NPM',
                        nl: 'NPM',
                        fr: 'La version la plus récente',
                        it: 'Nuova versione NPM',
                        es: 'Versión NPM más reciente',
                        pl: 'Nowa wersja NPM',
                        'zh-cn': '下一次主要国家预防计划',
                    },
                    type: 'string',
                    read: true,
                    write: false,
                    def: '',
                },
                native: {},
            },
        ];

        for (let i = 0; i < states.length; i++) {
            await adapter.setForeignObjectNotExistsAsync(`${prefix}.${states[i]._id}`, states[i]);
        }
        const keys = Object.keys(result);
        for (let k = 0; k < keys.length; k++) {
            await adapter.setForeignStateAsync(`${prefix}.${keys[k]}`, result[keys[k]].replace(/^v/, ''), true);
        }
    } catch (error) {
        adapter.log.warn('Cannot check node.js/npm version');
    }
}

function getData(adapter, callback) {
    adapter.log.info('requesting all states');
    /*
    tasks++;

    adapter.getForeignStates('*', (err, res) => {
        adapter.log.info('received all states');
        states = res;
        !--tasks && callback && callback();
    });*/

    adapter.log.info('requesting all objects');

    adapter.getObjectList({ include_docs: true }, (err, res) => {
        adapter.log.info('received all objects');
        if (res) {
            res = res.rows;
            objects = {};
            let tmpPath = '';
            for (let i = 0; i < res.length; i++) {
                objects[res[i].doc._id] = res[i].doc;
                if (res[i].doc.type === 'instance' && res[i].doc.common && res[i].doc.common.tmpPath) {
                    tmpPath && adapter.log.warn('tmpPath has multiple definitions!!');
                    tmpPath = res[i].doc.common.tmpPath;
                }
            }

            // Some adapters want access on specified tmp directory
            if (tmpPath) {
                adapter.config.tmpPath = tmpPath;
                adapter.config.tmpPathAllow = true;
            }

            createUpdateInfo(adapter).then(() => writeUpdateInfo(adapter));
        }

        callback && callback(adapter);
    });
}

async function checkRevokedVersions(repository) {
    try {
        const adapters = Object.keys(repository);
        const instances = await adapter.getObjectViewAsync('system', 'instance', {
            startkey: 'system.adapter.',
            endkey: 'system.adapter.\u9999',
        });

        for (let a = 0; a < adapters.length; a++) {
            const _adapter = adapters[a];
            if (repository[_adapter].blockedVersions) {
                // read current version
                if (Array.isArray(repository[_adapter].blockedVersions)) {
                    const instance = instances.rows.find(
                        item => item.value.common.name === _adapter && item.value.common.enabled
                    );
                    if (instance && instance.value.common && instance.value.common.version) {
                        for (let i = 0; i < repository[_adapter].blockedVersions.length; i++) {
                            try {
                                if (
                                    semver.satisfies(
                                        instance.value.common.version,
                                        repository[_adapter].blockedVersions[i]
                                    )
                                ) {
                                    // stop all instances
                                    for (let k = 0; k < instances.rows.length; k++) {
                                        const obj = instances.rows[k].value;
                                        if (obj.common.enabled && obj.common.name === _adapter) {
                                            obj.common.enabled = false;
                                            await adapter.setForeignObjectAsync(obj._id, obj);
                                            adapter.log.warn(
                                                `Instance ${obj._id.replace(
                                                    'system.adapter.',
                                                    ''
                                                )} was disabled because blocked. Please update ${_adapter} to newer or available version`
                                            );
                                            adapter.sendToHost(obj.common.host, 'addNotification', {
                                                scope: 'system',
                                                category: 'accessErrors', // change to 'blocked' when js-controller 4.1. released
                                                instance: obj._id,
                                                message: `Instance version was blocked. Please check for updates and update before restarting the instance`,
                                            });
                                        }
                                    }
                                }
                            } catch (e) {
                                _adapter.log.error(
                                    `Cannot check revoked versions: ${repository[_adapter].blockedVersions[i]}`
                                );
                                // ignore
                            }
                        }
                    }
                } else {
                    _adapter.log.error(
                        `Invalid blockedVersions for ${_adapter}: ${JSON.stringify(
                            repository[_adapter].blockedVersions
                        )}. Expected array like ["<= 3.17.4"] or also ["~3.14.0", "~3.15.0", "~3.16.0"]`
                    );
                }
            }
        }
    } catch (e) {
        adapter.log.error(`Cannot check revoked versions: ${e}`);
    }
}

// update icons by all known default objects. Remove this function after 2 years (BF: 2021.04.20)
function updateIcons() {
    if (fs.existsSync(`${utils.controllerDir}/io-package.json`)) {
        const ioPackage = require(`${utils.controllerDir}/io-package.json`);
        ioPackage.objects.forEach(async obj => {
            if (obj.common && obj.common.icon && obj.common.icon.length > 50) {
                const cObj = await adapter.getForeignObjectAsync(obj._id);
                if (cObj && (!cObj.common.icon || cObj.common.icon.length < 50)) {
                    adapter.log.debug(`Update icon for ${cObj._id}`);
                    cObj.common.icon = obj.common.icon;
                    await adapter.setForeignObjectAsync(cObj._id, cObj);
                }
            }
        });
    }
}

// read repository information from active repository
function updateRegister(isForce) {
    if (!isForce && lastRepoUpdate && Date.now() - lastRepoUpdate < 3600000) {
        adapter.log.error('Automatic repository update is not allowed more than once a hour');
        if (adapter.config.autoUpdate) {
            adapter.timerRepo && clearTimeout(adapter.timerRepo);
            adapter.timerRepo = setTimeout(
                () => {
                    adapter.timerRepo = null;
                    updateRegister();
                },
                adapter.config.autoUpdate * ONE_HOUR_MS + 1
            );
        }
        return;
    }

    lastRepoUpdate = Date.now();

    adapter.getForeignObject('system.config', (err, systemConfig) => {
        err && adapter.log.error('May not read "system.config"');

        if (systemConfig && systemConfig.common) {
            adapter.getForeignObject('system.repositories', (err, repos) => {
                err && adapter.log.error('May not read "system.repositories"');
                // Check if repositories exists
                let exists = false;
                const active = systemConfig.common.activeRepo;

                // if repo is valid and actual
                if (
                    !err &&
                    repos &&
                    repos.native &&
                    repos.native.repositories &&
                    repos.native.repositories[active] &&
                    Date.now() < repos.ts + adapter.config.autoUpdate * ONE_HOUR_MS
                ) {
                    exists = true;
                }

                if (!exists || isForce) {
                    adapter.log.info('Request actual repository...');
                    // request repo from host
                    adapter.sendToHost(
                        adapter.host,
                        'getRepository',
                        {
                            repo: active,
                            update: true,
                        },
                        _repository => {
                            if (_repository === ERROR_PERMISSION) {
                                adapter.log.error('May not read "getRepository"');
                            } else {
                                adapter.log.info('Repository received successfully.');

                                socket && socket.repoUpdated();
                                checkRevokedVersions(_repository).then(() => {});
                            }

                            // start next cycle
                            if (adapter.config.autoUpdate) {
                                adapter.timerRepo && clearTimeout(adapter.timerRepo);
                                adapter.log.debug(
                                    `Next repo update on ${new Date(
                                        Date.now() + adapter.config.autoUpdate * ONE_HOUR_MS + 1
                                    ).toLocaleString()}`
                                );
                                adapter.timerRepo = setTimeout(
                                    () => {
                                        adapter.timerRepo = null;
                                        updateRegister();
                                    },
                                    adapter.config.autoUpdate * ONE_HOUR_MS + 1
                                );
                            }
                        }
                    );
                } else if (adapter.config.autoUpdate) {
                    let interval = repos.ts + adapter.config.autoUpdate * ONE_HOUR_MS - Date.now() + 1;
                    if (interval > 0x7fffffff) {
                        interval = 0x7fffffff;
                    }
                    adapter.log.debug(`Next repo update on ${new Date(Date.now() + interval).toLocaleString()}`);
                    adapter.timerRepo && clearTimeout(adapter.timerRepo);
                    adapter.timerRepo = setTimeout(() => {
                        adapter.timerRepo = null;
                        updateRegister();
                    }, interval);
                }
            });
        }
    });
}

// If started as allInOne mode => return function to create instance
if (module && module.parent) {
    module.exports = startAdapter;
} else {
    // or start the instance directly
    startAdapter();
}
